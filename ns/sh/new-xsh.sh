#!/usr/bin/env bash
# ####################################
# Copyright © 2018 - 2021 by Renaud Guillard (dev@nore.fr)
# Distributed under the terms of the MIT License, see LICENSE
# Author: Renaud Guillard
# Version: 2.1.0
# 
# A script to create XSH (XML + SH) files
#
# Program help
usage()
{
cat << 'EOFUSAGE'
new-xsh: A script to create XSH (XML + SH) files

Usage: 
  new-xsh -n <string> [-o <path>] [[-e] -O <...  [ ... ]> -F <...  [ ... ]>] [--help] [--version] [--ns-xml-path <path>]
  
  Options:
    -n, --name: XSH program name
    -o, --output, --path: Output path  
      Default value: .
    Program content
      -e, --embed: Embed pre-defined content
      -O, --options: Predefined options  
        The argument have to be one of the following:  
          help, version or subcommand-names
      -F, --functions: Functions to include from built-in library or user 
      defined XSH file
        Arguments can be a short path of XSH library resource or an arbitrary 
        XSH file
        Exemple: text/sed to include ns/xsh/lib/text/sed.xsh file
    
    --help: Display program usage
    --version: Display program version
    --ns-xml-path: ns-xml source path
      Location of the ns folder of ns-xml package

  This program create the basic files needed by build-shellscript.sh to build 
  a shell script with autogenerated usage and argument parsing

EOFUSAGE
}

# Program parameter parsing
parser_program_author="Renaud Guillard"
parser_program_version="2.1.0"
if [ -r /proc/$$/exe ]
then
	parser_shell="$(readlink /proc/$$/exe | sed "s/.*\/\([a-z]*\)[0-9]*/\1/g")"
else
	parser_shell="$(basename "$(ps -p $$ -o command= | cut -f 1 -d' ')")"
fi

parser_input=("${@}")
parser_itemcount=${#parser_input[*]}
parser_startindex=0
parser_index=0
parser_subindex=0
parser_item=''
parser_option=''
parser_optiontail=''
parser_subcommand=''
parser_subcommand_expected=false
parser_subcommand_names=()
PARSER_OK=0
PARSER_ERROR=1
PARSER_SC_OK=0
PARSER_SC_ERROR=1
PARSER_SC_UNKNOWN=2
PARSER_SC_SKIP=3
[ "${parser_shell}" = 'zsh' ] && parser_startindex=1
parser_itemcount=$(expr ${parser_startindex} + ${parser_itemcount})
parser_index=${parser_startindex}


parser_required[$(expr ${#parser_required[*]} + ${parser_startindex})]="G_1_name:--name:"

programContentEmbed=false
displayHelp=false
displayVersion=false
xshName=
outputPath=
nsxmlPath=

parse_addwarning()
{
	local message="${1}"
	local m="[${parser_option}:${parser_index}:${parser_subindex}] ${message}"
	parser_warnings[$(expr ${#parser_warnings[*]} + ${parser_startindex})]="${m}"
}
parse_adderror()
{
	local message="${1}"
	local m="[${parser_option}:${parser_index}:${parser_subindex}] ${message}"
	parser_errors[$(expr ${#parser_errors[*]} + ${parser_startindex})]="${m}"
}
parse_addfatalerror()
{
	local message="${1}"
	local m="[${parser_option}:${parser_index}:${parser_subindex}] ${message}"
	parser_errors[$(expr ${#parser_errors[*]} + ${parser_startindex})]="${m}"
	parser_aborted=true
}

parse_displayerrors()
{
	for error in "${parser_errors[@]}"
	do
		echo -e "\t- ${error}"
	done
}


parse_pathaccesscheck()
{
	local file="${1}"
	[ ! -a "${file}" ] && return 0
	
	local accessString="${2}"
	while [ ! -z "${accessString}" ]
	do
		[ -${accessString:0:1} ${file} ] || return 1;
		accessString=${accessString:1}
	done
	return 0
}
parse_addrequiredoption()
{
	local id="${1}"
	local tail="${2}"
	local o=
	for o in "${parser_required[@]}"
	do
		local idPart="$(echo "${o}" | cut -f 1 -d":")"
		[ "${id}" = "${idPart}" ] && return 0
	done
	parser_required[$(expr ${#parser_required[*]} + ${parser_startindex})]="${id}:${tail}"
}
parse_setoptionpresence()
{
	parse_isoptionpresent "${1}" && return 0
	
	case "${1}" in
	G_3_g_1_embed)
		;;
	G_3_g_2_options)
		;;
	G_3_g_3_functions)
		;;
	
	esac
	case "${1}" in
	G_3_g)
		;;
	
	esac
	parser_present[$(expr ${#parser_present[*]} + ${parser_startindex})]="${1}"
	return 0
}
parse_isoptionpresent()
{
	local _e_found=false
	local _e=
	for _e in "${parser_present[@]}"
	do
		if [ "${_e}" = "${1}" ]
		then
			_e_found=true; break
		fi
	done
	if ${_e_found}
	then
		return 0
	else
		return 1
	fi
}
parse_checkrequired()
{
	[ ${#parser_required[*]} -eq 0 ] && return 0
	local c=0
	for o in "${parser_required[@]}"
	do
		local idPart="$(echo "${o}" | cut -f 1 -d":")"
		local _e_found=false
		local _e=
		for _e in "${parser_present[@]}"
		do
			if [ "${_e}" = "${idPart}" ]
			then
				_e_found=true; break
			fi
		done
		if ! (${_e_found})
		then
			local displayPart="$(echo "${o}" | cut -f 2 -d":")"
			parser_errors[$(expr ${#parser_errors[*]} + ${parser_startindex})]="Missing required option ${displayPart}"
			c=$(expr ${c} + 1)
		fi
	done
	return ${c}
}
parse_setdefaultoptions()
{
	local parser_set_default=false
	
	parser_set_default=true
	parse_isoptionpresent G_2_output && parser_set_default=false
	if ${parser_set_default}
	then
		outputPath='.'
		parse_setoptionpresence G_2_output
	fi
}
parse_checkminmax()
{
	local errorCount=0
	return ${errorCount}
}
parse_numberlesserequalcheck()
{
	local hasBC=false
	which bc 1>/dev/null 2>&1 && hasBC=true
	if ${hasBC}
	then
		[ "$(echo "${1} <= ${2}" | bc)" = "0" ] && return 1
	else
		local a_int="$(echo "${1}" | cut -f 1 -d".")"
		local a_dec="$(echo "${1}" | cut -f 2 -d".")"
		[ "${a_dec}" = "${1}" ] && a_dec="0"
		local b_int="$(echo "${2}" | cut -f 1 -d".")"
		local b_dec="$(echo "${2}" | cut -f 2 -d".")"
		[ "${b_dec}" = "${2}" ] && b_dec="0"
		[ ${a_int} -lt ${b_int} ] && return 0
		[ ${a_int} -gt ${b_int} ] && return 1
		([ ${a_int} -ge 0 ] && [ ${a_dec} -gt ${b_dec} ]) && return 1
		([ ${a_int} -lt 0 ] && [ ${b_dec} -gt ${a_dec} ]) && return 1
	fi
	return 0
}
parse_enumcheck()
{
	local ref="${1}"
	shift 1
	while [ $# -gt 0 ]
	do
		[ "${ref}" = "${1}" ] && return 0
		shift
	done
	return 1
}
parse_addvalue()
{
	local position=${#parser_values[*]}
	local value=
	if [ $# -gt 0 ] && [ ! -z "${1}" ]; then value="${1}"; else return ${PARSER_ERROR}; fi
	shift
	if [ -z "${parser_subcommand}" ]
	then
		${parser_isfirstpositionalargument} && parser_errors[$(expr ${#parser_errors[*]} + ${parser_startindex})]='Program does not accept positional arguments'
		
		parser_isfirstpositionalargument=false
		return ${PARSER_ERROR}
	else
		case "${parser_subcommand}" in
		*)
			return ${PARSER_ERROR}
			;;
		
		esac
	fi
	parser_values[$(expr ${#parser_values[*]} + ${parser_startindex})]="${value}"
}
parse_process_subcommand_option()
{
	parser_item="${parser_input[${parser_index}]}"
	if [ -z "${parser_item}" ] || [ "${parser_item:0:1}" != "-" ] || [ "${parser_item}" = '--' ]
	then
		return ${PARSER_SC_SKIP}
	fi
	
	return ${PARSER_SC_SKIP}
}
parse_process_option()
{
	if [ ! -z "${parser_subcommand}" ] && [ "${parser_item}" != '--' ]
	then
		parse_process_subcommand_option && return ${PARSER_OK}
		[ ${parser_index} -ge ${parser_itemcount} ] && return ${PARSER_OK}
	fi
	
	parser_item="${parser_input[${parser_index}]}"
	
	[ -z "${parser_item}" ] && return ${PARSER_OK}
	
	if [ "${parser_item}" = '--' ]
	then
		for ((a=$(expr ${parser_index} + 1);${a}<=$(expr ${parser_itemcount} - 1);a++))
		do
			parse_addvalue "${parser_input[${a}]}"
		done
		parser_index=${parser_itemcount}
		return ${PARSER_OK}
	elif [ "${parser_item}" = "-" ]
	then
		return ${PARSER_OK}
	elif [ "${parser_item:0:2}" = "\-" ]
	then
		parse_addvalue "${parser_item:1}"
	elif [ "${parser_item:0:2}" = '--' ] 
	then
		parser_option="${parser_item:2}"
		parser_optionhastail=false
		if echo "${parser_option}" | grep '=' 1>/dev/null 2>&1
		then
			parser_optionhastail=true
			parser_optiontail="$(echo "${parser_option}" | cut -f 2- -d"=")"
			parser_option="$(echo "${parser_option}" | cut -f 1 -d"=")"
		fi
		
		case "${parser_option}" in
		name)
			if ${parser_optionhastail}
			then
				parser_item=${parser_optiontail}
			else
				parser_index=$(expr ${parser_index} + 1)
				if [ ${parser_index} -ge ${parser_itemcount} ]
				then
					parse_adderror "End of input reached - Argument expected"
					return ${PARSER_ERROR}
				fi
				
				parser_item="${parser_input[${parser_index}]}"
				if [ "${parser_item}" = '--' ]
				then
					parse_adderror "End of option marker found - Argument expected"
					parser_index=$(expr ${parser_index} - 1)
					return ${PARSER_ERROR}
				fi
			fi
			
			parser_subindex=0
			parser_optiontail=''
			parser_optionhastail=false
			[ "${parser_item:0:2}" = "\-" ] && parser_item="${parser_item:1}"
			! parse_setoptionpresence G_1_name && return ${PARSER_ERROR}
			
			xshName="${parser_item}"
			
			;;
		output | path)
			if ${parser_optionhastail}
			then
				parser_item=${parser_optiontail}
			else
				parser_index=$(expr ${parser_index} + 1)
				if [ ${parser_index} -ge ${parser_itemcount} ]
				then
					parse_adderror "End of input reached - Argument expected"
					return ${PARSER_ERROR}
				fi
				
				parser_item="${parser_input[${parser_index}]}"
				if [ "${parser_item}" = '--' ]
				then
					parse_adderror "End of option marker found - Argument expected"
					parser_index=$(expr ${parser_index} - 1)
					return ${PARSER_ERROR}
				fi
			fi
			
			parser_subindex=0
			parser_optiontail=''
			parser_optionhastail=false
			[ "${parser_item:0:2}" = "\-" ] && parser_item="${parser_item:1}"
			if [ ! -e "${parser_item}" ]
			then
				parse_adderror "Invalid path \"${parser_item}\" for option \"${parser_option}\""
				return ${PARSER_ERROR}
			fi
			
			if ! parse_pathaccesscheck "${parser_item}" "rw"
			then
				parse_adderror "Invalid path permissions for \"${parser_item}\", rw privilege(s) expected for option \"${parser_option}\""
				return ${PARSER_ERROR}
			fi
			
			if [ -a "${parser_item}" ] && ! ([ -d "${parser_item}" ])
			then
				parse_adderror "Invalid patn type for option \"${parser_option}\""
				return ${PARSER_ERROR}
			fi
			
			! parse_setoptionpresence G_2_output && return ${PARSER_ERROR}
			
			outputPath="${parser_item}"
			
			;;
		help)
			! parse_setoptionpresence G_4_help && return ${PARSER_ERROR}
			
			if ${parser_optionhastail} && [ ! -z "${parser_optiontail}" ]
			then
				parse_adderror "Option --${parser_option} does not allow an argument"
				parser_optiontail=''
				return ${PARSER_ERROR}
			fi
			displayHelp=true
			
			;;
		version)
			! parse_setoptionpresence G_5_version && return ${PARSER_ERROR}
			
			if ${parser_optionhastail} && [ ! -z "${parser_optiontail}" ]
			then
				parse_adderror "Option --${parser_option} does not allow an argument"
				parser_optiontail=''
				return ${PARSER_ERROR}
			fi
			displayVersion=true
			
			;;
		ns-xml-path)
			if ${parser_optionhastail}
			then
				parser_item=${parser_optiontail}
			else
				parser_index=$(expr ${parser_index} + 1)
				if [ ${parser_index} -ge ${parser_itemcount} ]
				then
					parse_adderror "End of input reached - Argument expected"
					return ${PARSER_ERROR}
				fi
				
				parser_item="${parser_input[${parser_index}]}"
				if [ "${parser_item}" = '--' ]
				then
					parse_adderror "End of option marker found - Argument expected"
					parser_index=$(expr ${parser_index} - 1)
					return ${PARSER_ERROR}
				fi
			fi
			
			parser_subindex=0
			parser_optiontail=''
			parser_optionhastail=false
			[ "${parser_item:0:2}" = "\-" ] && parser_item="${parser_item:1}"
			! parse_setoptionpresence G_6_ns_xml_path && return ${PARSER_ERROR}
			
			nsxmlPath="${parser_item}"
			
			;;
		embed)
			! parse_setoptionpresence G_3_g_1_embed && return ${PARSER_ERROR}
			
			! parse_setoptionpresence G_3_g && return ${PARSER_ERROR}
			
			if ${parser_optionhastail} && [ ! -z "${parser_optiontail}" ]
			then
				parse_adderror "Option --${parser_option} does not allow an argument"
				parser_optiontail=''
				return ${PARSER_ERROR}
			fi
			programContentEmbed=true
			
			;;
		options)
			parser_item=''
			${parser_optionhastail} && parser_item=${parser_optiontail}
			
			parser_subindex=0
			parser_optiontail=''
			parser_optionhastail=false
			[ "${parser_item:0:2}" = "\-" ] && parser_item="${parser_item:1}"
			local parser_ma_values=
			local parser_ma_local_count=0
			local parser_ma_total_count=${#programContentOptions[*]}
			unset parser_ma_values
			if [ ! -z "${parser_item}" ]
			then
				if ! ([ "${parser_item}" = 'help' ] || [ "${parser_item}" = 'version' ] || [ "${parser_item}" = 'subcommand-names' ])
				then
					parse_adderror "Invalid value for option \"${parser_option}\""
					
					return ${PARSER_ERROR}
				fi
				parser_ma_values[$(expr ${#parser_ma_values[*]} + ${parser_startindex})]="${parser_item}"
				parser_ma_total_count=$(expr ${parser_ma_total_count} + 1)
				parser_ma_local_count=$(expr ${parser_ma_local_count} + 1)
			fi
			
			local parser_nextitem="${parser_input[$(expr ${parser_index} + 1)]}"
			while [ ! -z "${parser_nextitem}" ] && [ "${parser_nextitem}" != '--' ] && [ ${parser_index} -lt ${parser_itemcount} ]
			do
				if [ ${parser_ma_local_count} -gt 0 ] && [ "${parser_nextitem:0:1}" = "-" ]
				then
					break
				fi
				
				parser_index=$(expr ${parser_index} + 1)
				parser_item="${parser_input[${parser_index}]}"
				[ "${parser_item:0:2}" = "\-" ] && parser_item="${parser_item:1}"
				if ! ([ "${parser_item}" = 'help' ] || [ "${parser_item}" = 'version' ] || [ "${parser_item}" = 'subcommand-names' ])
				then
					parse_adderror "Invalid value for option \"${parser_option}\""
					
					return ${PARSER_ERROR}
				fi
				parser_ma_values[$(expr ${#parser_ma_values[*]} + ${parser_startindex})]="${parser_item}"
				parser_ma_total_count=$(expr ${parser_ma_total_count} + 1)
				parser_ma_local_count=$(expr ${parser_ma_local_count} + 1)
				parser_nextitem="${parser_input[$(expr ${parser_index} + 1)]}"
			done
			if [ ${parser_ma_local_count} -eq 0 ]
			then
				parse_adderror "At least one argument expected for option \"${parser_option}\""
				return ${PARSER_ERROR}
			fi
			! parse_setoptionpresence G_3_g_2_options && return ${PARSER_ERROR}
			
			! parse_setoptionpresence G_3_g && return ${PARSER_ERROR}
			
			for ((i=$(expr 0 + ${parser_startindex});${i}<$(expr ${#parser_ma_values[*]} + ${parser_startindex});i++))
			do
				programContentOptions[${#programContentOptions[*]}]="${parser_ma_values[${i}]}"
			done
			
			;;
		functions)
			parser_item=''
			${parser_optionhastail} && parser_item=${parser_optiontail}
			
			parser_subindex=0
			parser_optiontail=''
			parser_optionhastail=false
			[ "${parser_item:0:2}" = "\-" ] && parser_item="${parser_item:1}"
			local parser_ma_values=
			local parser_ma_local_count=0
			local parser_ma_total_count=${#programContentFunctions[*]}
			unset parser_ma_values
			if [ ! -z "${parser_item}" ]
			then
				parser_ma_values[$(expr ${#parser_ma_values[*]} + ${parser_startindex})]="${parser_item}"
				parser_ma_total_count=$(expr ${parser_ma_total_count} + 1)
				parser_ma_local_count=$(expr ${parser_ma_local_count} + 1)
			fi
			
			local parser_nextitem="${parser_input[$(expr ${parser_index} + 1)]}"
			while [ ! -z "${parser_nextitem}" ] && [ "${parser_nextitem}" != '--' ] && [ ${parser_index} -lt ${parser_itemcount} ]
			do
				if [ ${parser_ma_local_count} -gt 0 ] && [ "${parser_nextitem:0:1}" = "-" ]
				then
					break
				fi
				
				parser_index=$(expr ${parser_index} + 1)
				parser_item="${parser_input[${parser_index}]}"
				[ "${parser_item:0:2}" = "\-" ] && parser_item="${parser_item:1}"
				parser_ma_values[$(expr ${#parser_ma_values[*]} + ${parser_startindex})]="${parser_item}"
				parser_ma_total_count=$(expr ${parser_ma_total_count} + 1)
				parser_ma_local_count=$(expr ${parser_ma_local_count} + 1)
				parser_nextitem="${parser_input[$(expr ${parser_index} + 1)]}"
			done
			if [ ${parser_ma_local_count} -eq 0 ]
			then
				parse_adderror "At least one argument expected for option \"${parser_option}\""
				return ${PARSER_ERROR}
			fi
			! parse_setoptionpresence G_3_g_3_functions && return ${PARSER_ERROR}
			
			! parse_setoptionpresence G_3_g && return ${PARSER_ERROR}
			
			for ((i=$(expr 0 + ${parser_startindex});${i}<$(expr ${#parser_ma_values[*]} + ${parser_startindex});i++))
			do
				programContentFunctions[${#programContentFunctions[*]}]="${parser_ma_values[${i}]}"
			done
			
			;;
		*)
			parse_addfatalerror "Unknown option \"${parser_option}\""
			return ${PARSER_ERROR}
			;;
		
		esac
	elif [ "${parser_item:0:1}" = "-" ] && [ ${#parser_item} -gt 1 ]
	then
		parser_optiontail="${parser_item:$(expr ${parser_subindex} + 2)}"
		parser_option="${parser_item:$(expr ${parser_subindex} + 1):1}"
		if [ -z "${parser_option}" ]
		then
			parser_subindex=0
			return ${PARSER_SC_OK}
		fi
		
		case "${parser_option}" in
		'n')
			if [ ! -z "${parser_optiontail}" ]
			then
				parser_item=${parser_optiontail}
			else
				parser_index=$(expr ${parser_index} + 1)
				if [ ${parser_index} -ge ${parser_itemcount} ]
				then
					parse_adderror "End of input reached - Argument expected"
					return ${PARSER_ERROR}
				fi
				
				parser_item="${parser_input[${parser_index}]}"
				if [ "${parser_item}" = '--' ]
				then
					parse_adderror "End of option marker found - Argument expected"
					parser_index=$(expr ${parser_index} - 1)
					return ${PARSER_ERROR}
				fi
			fi
			
			parser_subindex=0
			parser_optiontail=''
			parser_optionhastail=false
			[ "${parser_item:0:2}" = "\-" ] && parser_item="${parser_item:1}"
			! parse_setoptionpresence G_1_name && return ${PARSER_ERROR}
			
			xshName="${parser_item}"
			
			;;
		'o')
			if [ ! -z "${parser_optiontail}" ]
			then
				parser_item=${parser_optiontail}
			else
				parser_index=$(expr ${parser_index} + 1)
				if [ ${parser_index} -ge ${parser_itemcount} ]
				then
					parse_adderror "End of input reached - Argument expected"
					return ${PARSER_ERROR}
				fi
				
				parser_item="${parser_input[${parser_index}]}"
				if [ "${parser_item}" = '--' ]
				then
					parse_adderror "End of option marker found - Argument expected"
					parser_index=$(expr ${parser_index} - 1)
					return ${PARSER_ERROR}
				fi
			fi
			
			parser_subindex=0
			parser_optiontail=''
			parser_optionhastail=false
			[ "${parser_item:0:2}" = "\-" ] && parser_item="${parser_item:1}"
			if [ ! -e "${parser_item}" ]
			then
				parse_adderror "Invalid path \"${parser_item}\" for option \"${parser_option}\""
				return ${PARSER_ERROR}
			fi
			
			if ! parse_pathaccesscheck "${parser_item}" "rw"
			then
				parse_adderror "Invalid path permissions for \"${parser_item}\", rw privilege(s) expected for option \"${parser_option}\""
				return ${PARSER_ERROR}
			fi
			
			if [ -a "${parser_item}" ] && ! ([ -d "${parser_item}" ])
			then
				parse_adderror "Invalid patn type for option \"${parser_option}\""
				return ${PARSER_ERROR}
			fi
			
			! parse_setoptionpresence G_2_output && return ${PARSER_ERROR}
			
			outputPath="${parser_item}"
			
			;;
		'e')
			! parse_setoptionpresence G_3_g_1_embed && return ${PARSER_ERROR}
			
			! parse_setoptionpresence G_3_g && return ${PARSER_ERROR}
			
			programContentEmbed=true
			
			;;
		'O')
			parser_item=''
			${parser_optionhastail} && parser_item=${parser_optiontail}
			
			parser_subindex=0
			parser_optiontail=''
			parser_optionhastail=false
			[ "${parser_item:0:2}" = "\-" ] && parser_item="${parser_item:1}"
			local parser_ma_values=
			local parser_ma_local_count=0
			local parser_ma_total_count=${#programContentOptions[*]}
			unset parser_ma_values
			if [ ! -z "${parser_item}" ]
			then
				if ! ([ "${parser_item}" = 'help' ] || [ "${parser_item}" = 'version' ] || [ "${parser_item}" = 'subcommand-names' ])
				then
					parse_adderror "Invalid value for option \"${parser_option}\""
					
					return ${PARSER_ERROR}
				fi
				parser_ma_values[$(expr ${#parser_ma_values[*]} + ${parser_startindex})]="${parser_item}"
				parser_ma_total_count=$(expr ${parser_ma_total_count} + 1)
				parser_ma_local_count=$(expr ${parser_ma_local_count} + 1)
			fi
			
			local parser_nextitem="${parser_input[$(expr ${parser_index} + 1)]}"
			while [ ! -z "${parser_nextitem}" ] && [ "${parser_nextitem}" != '--' ] && [ ${parser_index} -lt ${parser_itemcount} ]
			do
				if [ ${parser_ma_local_count} -gt 0 ] && [ "${parser_nextitem:0:1}" = "-" ]
				then
					break
				fi
				
				parser_index=$(expr ${parser_index} + 1)
				parser_item="${parser_input[${parser_index}]}"
				[ "${parser_item:0:2}" = "\-" ] && parser_item="${parser_item:1}"
				if ! ([ "${parser_item}" = 'help' ] || [ "${parser_item}" = 'version' ] || [ "${parser_item}" = 'subcommand-names' ])
				then
					parse_adderror "Invalid value for option \"${parser_option}\""
					
					return ${PARSER_ERROR}
				fi
				parser_ma_values[$(expr ${#parser_ma_values[*]} + ${parser_startindex})]="${parser_item}"
				parser_ma_total_count=$(expr ${parser_ma_total_count} + 1)
				parser_ma_local_count=$(expr ${parser_ma_local_count} + 1)
				parser_nextitem="${parser_input[$(expr ${parser_index} + 1)]}"
			done
			if [ ${parser_ma_local_count} -eq 0 ]
			then
				parse_adderror "At least one argument expected for option \"${parser_option}\""
				return ${PARSER_ERROR}
			fi
			! parse_setoptionpresence G_3_g_2_options && return ${PARSER_ERROR}
			
			! parse_setoptionpresence G_3_g && return ${PARSER_ERROR}
			
			for ((i=$(expr 0 + ${parser_startindex});${i}<$(expr ${#parser_ma_values[*]} + ${parser_startindex});i++))
			do
				programContentOptions[${#programContentOptions[*]}]="${parser_ma_values[${i}]}"
			done
			
			;;
		'F')
			parser_item=''
			${parser_optionhastail} && parser_item=${parser_optiontail}
			
			parser_subindex=0
			parser_optiontail=''
			parser_optionhastail=false
			[ "${parser_item:0:2}" = "\-" ] && parser_item="${parser_item:1}"
			local parser_ma_values=
			local parser_ma_local_count=0
			local parser_ma_total_count=${#programContentFunctions[*]}
			unset parser_ma_values
			if [ ! -z "${parser_item}" ]
			then
				parser_ma_values[$(expr ${#parser_ma_values[*]} + ${parser_startindex})]="${parser_item}"
				parser_ma_total_count=$(expr ${parser_ma_total_count} + 1)
				parser_ma_local_count=$(expr ${parser_ma_local_count} + 1)
			fi
			
			local parser_nextitem="${parser_input[$(expr ${parser_index} + 1)]}"
			while [ ! -z "${parser_nextitem}" ] && [ "${parser_nextitem}" != '--' ] && [ ${parser_index} -lt ${parser_itemcount} ]
			do
				if [ ${parser_ma_local_count} -gt 0 ] && [ "${parser_nextitem:0:1}" = "-" ]
				then
					break
				fi
				
				parser_index=$(expr ${parser_index} + 1)
				parser_item="${parser_input[${parser_index}]}"
				[ "${parser_item:0:2}" = "\-" ] && parser_item="${parser_item:1}"
				parser_ma_values[$(expr ${#parser_ma_values[*]} + ${parser_startindex})]="${parser_item}"
				parser_ma_total_count=$(expr ${parser_ma_total_count} + 1)
				parser_ma_local_count=$(expr ${parser_ma_local_count} + 1)
				parser_nextitem="${parser_input[$(expr ${parser_index} + 1)]}"
			done
			if [ ${parser_ma_local_count} -eq 0 ]
			then
				parse_adderror "At least one argument expected for option \"${parser_option}\""
				return ${PARSER_ERROR}
			fi
			! parse_setoptionpresence G_3_g_3_functions && return ${PARSER_ERROR}
			
			! parse_setoptionpresence G_3_g && return ${PARSER_ERROR}
			
			for ((i=$(expr 0 + ${parser_startindex});${i}<$(expr ${#parser_ma_values[*]} + ${parser_startindex});i++))
			do
				programContentFunctions[${#programContentFunctions[*]}]="${parser_ma_values[${i}]}"
			done
			
			;;
		*)
			parse_addfatalerror "Unknown option \"${parser_option}\""
			return ${PARSER_ERROR}
			;;
		
		esac
	elif ${parser_subcommand_expected} && [ -z "${parser_subcommand}" ] && [ ${#parser_values[*]} -eq 0 ]
	then
		case "${parser_item}" in
		*)
			parse_addvalue "${parser_item}"
			;;
		
		esac
	else
		parse_addvalue "${parser_item}"
	fi
	return ${PARSER_OK}
}
parse()
{
	parser_aborted=false
	parser_isfirstpositionalargument=true
	while [ ${parser_index} -lt ${parser_itemcount} ] && ! ${parser_aborted}
	do
		parse_process_option
		if [ -z "${parser_optiontail}" ]
		then
			parser_index=$(expr ${parser_index} + 1)
			parser_subindex=0
		else
			parser_subindex=$(expr ${parser_subindex} + 1)
		fi
	done
	
	if ! ${parser_aborted}
	then
		parse_setdefaultoptions
		parse_checkrequired
		parse_checkminmax
	fi
	
	
	[ "${programContent:0:1}" = '@' ] && programContent=''
	programContent=''
	
	
	
	local parser_errorcount=${#parser_errors[*]}
	return ${parser_errorcount}
}

ns_print_error()
{
	local shell="$(readlink /proc/$$/exe | sed "s/.*\/\([a-z]*\)[0-9]*/\1/g")"
	local errorColor="${NSXML_ERROR_COLOR}"
	local useColor=false
	for s in bash zsh ash
	do
		if [ "${shell}" = "${s}" ]
		then
			useColor=true
			break
		fi
	done
	if ${useColor} 
	then
		[ -z "${errorColor}" ] && errorColor="31" 
		echo -e "\e[${errorColor}m${@}\e[0m"  1>&2
	else
		echo "${@}" 1>&2
	fi
}
ns_error()
{
	local errno=
	if [ $# -gt 0 ]
	then
		errno=${1}
		shift
	else
		errno=1
	fi
	local message="${@}"
	if [ -z "${errno##*[!0-9]*}" ]
	then
		message="${errno} ${message}"
		errno=1
	fi
	ns_print_error "${message}"
	exit ${errno}
}
nsxml_installpath()
{
	local subpath="share/ns"
	for prefix in \
		"${@}" \
		"${NSXML_PATH}" \
		"${HOME}/.local/${subpath}" \
		"${HOME}/${subpath}" \
		/usr/${subpath} \
		/usr/loca/${subpath}l \
		/opt/${subpath} \
		/opt/local/${subpath}
	do
		if [ ! -z "${prefix}" ] \
			&& [ -d "${prefix}" ] \
			&& [ -r "${prefix}/ns-xml.plist" ]
		then
			echo -n "${prefix}"
			return 0
		fi
	done
	
	ns_print_error "nsxml_installpath: Path not found"
	return 1
}
ns_array_contains()
{
	local needle=
	if [ $# -gt 0 ]
	then
		needle="${1}"
		shift
	fi
	for e in "${@}"
	do
		[ "${e}" = "${needle}" ] && return 0
	done
	return 1
}
ns_realpath()
{
	local __ns_realpath_in=
	if [ $# -gt 0 ]
	then
		__ns_realpath_in="${1}"
		shift
	fi
	local __ns_realpath_rl=
	local __ns_realpath_cwd="$(pwd)"
	[ -d "${__ns_realpath_in}" ] && cd "${__ns_realpath_in}" && __ns_realpath_in="."
	while [ -h "${__ns_realpath_in}" ]
	do
		__ns_realpath_rl="$(readlink "${__ns_realpath_in}")"
		if [ "${__ns_realpath_rl#/}" = "${__ns_realpath_rl}" ]
		then
			__ns_realpath_in="$(dirname "${__ns_realpath_in}")/${__ns_realpath_rl}"
		else
			__ns_realpath_in="${__ns_realpath_rl}"
		fi
	done
	
	if [ -d "${__ns_realpath_in}" ]
	then
		__ns_realpath_in="$(cd -P "$(dirname "${__ns_realpath_in}")" && pwd)"
	else
		__ns_realpath_in="$(cd -P "$(dirname "${__ns_realpath_in}")" && pwd)/$(basename "${__ns_realpath_in}")"
	fi
	
	cd "${__ns_realpath_cwd}" 1>/dev/null 2>&1
	echo "${__ns_realpath_in}"
}
ns_relativepath()
{
	local from=
	if [ $# -gt 0 ]
	then
		from="${1}"
		shift
	fi
	local base=
	if [ $# -gt 0 ]
	then
		base="${1}"
		shift
	else
		base="."
	fi
	[ -r "${from}" ] || return 1
	[ -r "${base}" ] || return 2
	[ ! -d "${base}" ] && base="$(dirname "${base}")"  
	[ -d "${base}" ] || return 3
	from="$(ns_realpath "${from}")"
	base="$(ns_realpath "${base}")"
	c=0
	sub="${base}"
	newsub=''
	while [ "${from:0:${#sub}}" != "${sub}" ]
	do
		newsub="$(dirname "${sub}")"
		[ "${newsub}" == "${sub}" ] && return 4
		sub="${newsub}"
		c="$(expr ${c} + 1)"
	done
	res='.'
	for ((i=0;${i}<${c};i++))
	do
		res="${res}/.."
	done
	[ "${sub}" != '/' ] \
		&& res="${res}${from#${sub}}" \
		|| res="${res}${from}"
	res="${res#./}"
	[ -z "${res}" ] && res='.'
	echo "${res}"
}
chunk_check_nsxml_ns_path()
{
	if [ ! -z "${nsxmlPath}" ]
	then
		if ${nsxmlPathRelative}
		then
			nsPath="${scriptPath}/${nsxmlPath}"
		else
			nsPath="${nsxmlPath}"
		fi
		
		[ -d "${nsPath}" ] || return 1
		
		nsPath="$(ns_realpath "${nsPath}")"
	fi
	[ -d "${nsPath}" ]
}
get_program_version()
{
	local file=
	if [ $# -gt 0 ]
	then
		file="${1}"
		shift
	fi
	local tmpXslFile="/tmp/get_program_version.xsl"
	cat > "${tmpXslFile}" << GETPROGRAMVERSIONXSLEOF
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:prg="http://xsd.nore.fr/program">
	<xsl:output method="text" encoding="utf-8" />
	<xsl:template match="//prg:program">
		<xsl:value-of select="@version" />
		<xsl:text>&#10;</xsl:text>
	</xsl:template>
</xsl:stylesheet>
GETPROGRAMVERSIONXSLEOF


	local result="$(xsltproc --xinclude "${tmpXslFile}" "${file}")"
	rm -f "${tmpXslFile}"
	if [ ! -z "${result##*[!0-9.]*}" ]
	then
		echo "${result}"
		return 0
	else
		return 1
	fi

	
}
xml_validate()
{
	local schema=
	if [ $# -gt 0 ]
	then
		schema="${1}"
		shift
	fi
	local xml=
	if [ $# -gt 0 ]
	then
		xml="${1}"
		shift
	fi
	local tmpOut="/tmp/xml_validate.tmp"
	if ! xmllint --xinclude --noout --schema "${schema}" "${xml}" 1>"${tmpOut}" 2>&1
	then
		cat "${tmpOut}"
		echo "Schema: ${scheam}"
		echo "File: ${xml}"
		return 1
	fi
	
	return 0
}
# Global variables
cwd="$(pwd)"
scriptFilePath="$(ns_realpath "${0}")"
scriptPath="$(dirname "${scriptFilePath}")"
scriptName="$(basename "${scriptFilePath}")"
programSchemaVersion="2.0"

tmpPath="/tmp"
[ ! -z "${TMPDIR}" ] && [ -d "${TMPDIR}" ] && tmpPath="${TMPDIR%/}/"
author=''
if [ ! -z "${USER}" ]; then author="${USER}"
elif [ ! -z "${LOGNAME}" ]; then author="${LOGNAME}"
fi
 
# Check required programs
for x in xmllint xsltproc
do
	if ! which $x 1>/dev/null 2>&1
	then
		echo "${x} program not found"
		exit 1
	fi
done

if ! parse "${@}"
then
	${displayHelp} && usage && exit 0
	${displayVersion} && echo "${parser_program_version}" && exit 0
	
	parse_displayerrors 1>&2 && exit 1
fi

${displayHelp} && usage && exit 0
${displayVersion} && echo "${parser_program_version}" && exit 0

#######################################

[ -d "${nsxmlPath}" ] || nsxmlPath="${scriptPath}/../.."
[ ! -d "${nsxmlPath}" ] && ns_error "ns-xml path path not found"
nsxmlPath="$(ns_realpath "${nsxmlPath}")"

mkdir -p "${outputPath}" || ns_error "Failed to create output path"

outputPath="$(ns_realpath "${outputPath}")"

xshSchemaFile="${nsxmlPath}/ns/xsd/xsh/1.0/xsh.xsd"
xshFile="${outputPath}/${xshName}.xsh"
xmlFile="${outputPath}/${xshName}.xml"
shFile="${outputPath}/${xshName}.body.sh"
tmpFile="${tmpPath}/${xshName}.tmp"

for f in "${xshFile}" "${xmlFile}" "${shFile}"
do
	[ -f "${f}" ] && ns_error 1 "${f} already exists"
done

# XSH file
cat > "${tmpFile}" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<xsh:program 
	interpreterType="bash" 
	xmlns:prg="http://xsd.nore.fr/program" 
	xmlns:xsh="http://xsd.nore.fr/xsh" 
	xmlns:xi="http://www.w3.org/2001/XInclude">
	<xsh:info>
		<xi:include href="${xshName}.xml" />
	</xsh:info>
EOF
if [ ${#programContentFunctions[*]} -gt 0 ]
then
	echo '	<xsh:functions>' >> "${tmpFile}"
	for resource in "${programContentFunctions[@]}"
	do
		cd "${cwd}"
		resourcePath=''
		if [ -r "${resource}" ]
		then
			xmllint --noout \
				--schema "${xshSchemaFile}" \
				"${resource}" \
				1>/dev/null 2>&1 \
			|| ns_error "Invalid XSH file ${resource}"

			resourcePath="$(ns_realpath "${resource}")"
		else
			resourcePath="${nsxmlPath}/ns/xsh/lib/${resource}.xsh"
		fi
		
		[ -f "${resourcePath}" ] \
			|| ns_error "Function file not found: ${resourcePath}" 

		if ${programContentEmbed}
		then
			xmllint --xpath \
				"//*[local-name() = 'function' and namespace-uri() = 'http://xsd.nore.fr/xsh']" \
				"${resourcePath}" \
				>> "${tmpFile}"
		else
			relativePath="$(ns_relativepath "${resourcePath}" "${outputPath}")"
			echo "		<xi:include href="\"${relativePath}"\" xpointer=\"xmlns(xsh=http://xsd.nore.fr/xsh) xpointer(//xsh:function)\" />" >> "${tmpFile}"
		fi
	done 
	echo '	</xsh:functions>' >> "${tmpFile}"		
fi

cat >> "${tmpFile}" << EOF
	<xsh:code>
		<!-- Include shell script code -->
		<xi:include href="${xshName}.body.sh" parse="text" />
	</xsh:code>
</xsh:program>
EOF

xmllint --format --output "${xshFile}" "${tmpFile}"

# XML file
cat > "${tmpFile}" << EOF
<?xml version="1.0" encoding="utf-8"?>
<prg:program xmlns:prg="http://xsd.nore.fr/program" version="2.0" xmlns:xi="http://www.w3.org/2001/XInclude">
	<prg:name>${xshName}</prg:name>
	<prg:author>${author}</prg:author>
	<prg:version>1.0.0</prg:version>
	<prg:copyright>Copyright © $(date +%Y) by ${author}</prg:copyright>
	<prg:documentation>
		<prg:abstract>${xshName} short description</prg:abstract>
	</prg:documentation>
EOF
if [ ${#programContentOptions[*]} -gt 0 ]
then
	echo '	<prg:options>' >> "${tmpFile}"
	for o in "${programContentOptions[@]}"
	do
		resourcePath="${nsxmlPath}/ns/xsh/lib/options/options.xml"
		optionIdentifier=''
		optionType='prg:switch'
		case "${o}" in
			help)
				optionIdentifier='prg.option.displayHelp'
				;;
			subcommand-names)
				optionIdentifier='prg.option.displaySubcommandNames'
				;;
			version)
				optionIdentifier='prg.option.displayVersion'
				;;
		esac
		
		if ${programContentEmbed}
		then
			xmllint --xpath \
				"//*[local-name() = '${optionType#prg:}' and @id = '${optionIdentifier}' and namespace-uri() = 'http://xsd.nore.fr/program']" \
				"${resourcePath}" \
				>> "${tmpFile}"
		else
			resourcePath="$(ns_relativepath "${resourcePath}" "${outputPath}")"
			echo "<xi:include href=\"${resourcePath}\" xpointer=\"xmlns(prg=http://xsd.nore.fr/program) xpointer(//${optionType}[@id = '${optionIdentifier}'])\" />" \
				>> "${tmpFile}"
		fi
	done
	 
	echo '	</prg:options>' >> "${tmpFile}"
fi

echo '</prg:program>' >> "${tmpFile}"

xmllint --format --output "${xmlFile}" "${tmpFile}"

## SH body

touch "${shFile}"

cat > "${shFile}" << EOF
# Global variables
EOF
if ns_array_contains filesystem/filesystem "${programContentFunctions[@]}"
then
	cat >> "${shFile}" << EOF
scriptFilePath="\$(ns_realpath "\${0}")"
EOF
else
	cat >> "${shFile}" << EOF
scriptFilePath="\${0}"
EOF
fi

cat >> "${shFile}" << EOF
scriptPath="\$(dirname "\${scriptFilePath}")"
scriptName="\$(basename "\${scriptFilePath}")"

# Option parsing
if ! parse "\${@}"
then
EOF
if ns_array_contains help "${programContentOptions[@]}"
then
	cat >> "${shFile}" << EOF
	\${displayHelp} && usage "\${parser_subcommand}" && exit 0
EOF
fi
if ns_array_contains 'subcommand-names' "${programContentOptions[@]}"
then
	cat >> "${shFile}" << EOF
	\${displaySubcommandNames} \\
		&& for n in "\${parser_subcommand_names[@]}"; do echo "\${n}"; done \\
		&& exit 0
EOF
fi
if ns_array_contains version "${programContentOptions[@]}"
then
	cat >> "${shFile}" << EOF
	\${displayVersion} && echo "\${parser_program_version}" && exit 0
EOF
fi
cat >> "${shFile}" << EOF
	parse_displayerrors 1>&2
	exit 1
fi
EOF
if ns_array_contains help "${programContentOptions[@]}"
then
	cat >> "${shFile}" << EOF
\${displayHelp} && usage "\${parser_subcommand}" && exit 0
EOF
fi

if ns_array_contains 'subcommand-names' "${programContentOptions[@]}"
then
	cat >> "${shFile}" << EOF
\${displaySubcommandNames} \\
	&& for n in "\${parser_subcommand_names[@]}"; do echo "\${n}"; done \\
	&& exit 0 
EOF
fi
if ns_array_contains version "${programContentOptions[@]}"
then
	cat >> "${shFile}" << EOF
\${displayVersion} && echo "\${parser_program_version}" && exit 0
EOF
fi

cat >> "${shFile}" << EOF
# Main code

EOF
